
export declare function createResolveLocale<K extends string, D extends {
    [k in K]: any;
}>(getDefaultLocale: () => string): (availableLocales: string[], requestedLocales: string[], options: {
    [k: string]: string;
    localeMatcher: string;
}, relevantExtensionKeys: K[], localeData: Record<string, D>) => ResolveLocaleResult;

export declare interface CurrencyData {
    displayName: CurrencyPattern;
    symbol: string;
    narrowSymbol?: string;
    variantSymbol?: string;
}

declare interface CurrencyPattern {
    one?: string;
    other: string;
}

export declare interface FieldData {
    '0'?: string;
    '1'?: string;
    '-1'?: string;
    '2'?: string;
    '-2'?: string;
    '3'?: string;
    '-3'?: string;
    future: RelativeTimeData;
    past: RelativeTimeData;
}

export declare function getAliasesByLang(lang: string): Record<string, string>;

/**
 * IE11-safe version of getCanonicalLocales since it's ES2016
 * @param locales locales
 */
export declare function getCanonicalLocales(locales?: string | string[]): string[];

export declare function getInternalSlot<Instance extends object, Internal, Field extends keyof Internal>(map: WeakMap<Instance, Internal>, pl: Instance, field: Field): Internal[Field];

export declare function getLocaleHierarchy(locale: string, aliases: Record<string, string>, parentLocales: Record<string, string>): string[];

/**
 * https://tc39.es/ecma402/#sec-getoption
 * @param opts
 * @param prop
 * @param type
 * @param values
 * @param fallback
 */
export declare function getOption<T extends object, K extends keyof T>(opts: T, prop: K, type: 'string' | 'boolean', values?: T[K][], fallback?: T[K]): T[K] | undefined;

export declare function getParentLocalesByLang(lang: string): Record<string, string>;

export declare function invariant(condition: boolean, message: string, Err?: any): void;

export declare function isLiteralPart(patternPart: LiteralPart | {
    type: string;
    value?: string;
}): patternPart is LiteralPart;

export declare function isMissingLocaleDataError(e: Error): e is MissingLocaleDataError;

export declare type LDMLPluralRule = 'zero' | 'one' | 'two' | 'few' | 'many' | 'other';

export declare interface ListPattern {
    start: string;
    middle: string;
    end: string;
    pair: string;
}

export declare interface ListPatternData {
    long: ListPattern;
    short?: ListPattern;
    narrow?: ListPattern;
}

export declare interface ListPatternFieldsData {
    conjunction?: ListPatternData;
    disjunction?: ListPatternData;
    unit?: ListPatternData;
}

export declare type ListPatternLocaleData = LocaleData<ListPatternFieldsData>;

export declare interface LiteralPart {
    type: 'literal';
    value: string;
}

declare type Locale = string;

declare interface LocaleData<T> {
    data: Record<Locale, T>;
    aliases: Record<string, string>;
    availableLocales: string[];
    parentLocales: Record<string, string>;
}

export declare type LocaleFieldsData = {
    [f in RelativeTimeField]?: FieldData;
} & {
    nu?: Array<string | null>;
};

declare class MissingLocaleDataError extends Error {
    type: string;
}

export declare function partitionPattern(pattern: string): ({
    type: string;
    value: string;
} | {
    type: string;
    value: undefined;
})[];

export declare interface PluralRulesData {
    categories: {
        cardinal: string[];
        ordinal: string[];
    };
    fn: (val: number | string, ord?: boolean) => LDMLPluralRule;
}

export declare type PluralRulesLocaleData = LocaleData<PluralRulesData>;

declare type RelativeTimeData = {
    [u in LDMLPluralRule]?: string;
};

export declare type RelativeTimeField = 'second' | 'second-short' | 'second-narrow' | 'minute' | 'minute-short' | 'minute-narrow' | 'hour' | 'hour-short' | 'hour-narrow' | 'day' | 'day-short' | 'day-narrow' | 'week' | 'week-short' | 'week-narrow' | 'month' | 'month-short' | 'month-narrow' | 'quarter' | 'quarter-short' | 'quarter-narrow' | 'year' | 'year-short' | 'year-narrow';

export declare type RelativeTimeLocaleData = LocaleData<LocaleFieldsData>;

declare interface ResolveLocaleResult {
    locale: string;
    dataLocale: string;
    [k: string]: any;
}

export declare const SANCTIONED_UNITS: string[];

export declare function selectUnit(from: Date | number, to?: Date | number, thresholds?: Partial<Thresholds>): {
    value: number;
    unit: Unit;
};

export declare function setInternalSlot<Instance extends object, Internal, Field extends keyof Internal>(map: WeakMap<Instance, Internal>, pl: Instance, field: Field, value: Internal[Field]): void;

export declare function supportedLocales(availableLocales: string[], requestedLocales: string[], options?: {
    localeMatcher?: 'best fit' | 'lookup';
}): string[];

declare type Thresholds = Record<'second' | 'minute' | 'hour' | 'day', number>;

/**
 * https://tc39.es/ecma262/#sec-toobject
 * @param arg
 */
export declare function toObject<T>(arg: T): T extends null ? never : T extends undefined ? never : T;

export declare type UnifiedNumberFormatLocaleData = LocaleData<{
    /** unit name -> data mapping */
    units?: Record<string, UnitData>;
    /** currency ISO code -> currency data mapping */
    currencies?: Record<string, Pick<CurrencyData, 'narrowSymbol'>>;
}>;

declare type Unit = 'second' | 'minute' | 'hour' | 'day' | 'week' | 'month' | 'quarter' | 'year';

export declare interface UnitData {
    displayName: string;
    long: UnitPattern;
    short?: UnitPattern;
    narrow?: UnitPattern;
}

declare interface UnitPattern {
    one?: string;
    other?: string;
}

export declare function unpackData<T extends Record<string, any>>(locale: string, localeData: LocaleData<T>, 
/** By default shallow merge the dictionaries. */
reducer?: (all: T, d: T) => T): T;

export declare type UnpackedLocaleFieldsData = {
    [f in RelativeTimeField]?: FieldData;
} & {
    nu: Array<string | null>;
};

export { }
