"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function findReferenceImport(id, importedVars) {
    return importedVars.find(v => !!v.references.find(ref => ref.identifier === id));
}
function isIntlFormatMessageCall(node) {
    return (node.type === 'CallExpression' &&
        node.callee.type === 'MemberExpression' &&
        node.callee.object.type === 'Identifier' &&
        node.callee.object.name === 'intl' &&
        node.callee.property.type === 'Identifier' &&
        node.callee.property.name === 'formatMessage' &&
        node.arguments.length >= 1 &&
        node.arguments[0].type === 'ObjectExpression');
}
function isSingleMessageDescriptorDeclaration(id, importedVars) {
    const importedVar = findReferenceImport(id, importedVars);
    if (!importedVar) {
        return false;
    }
    return importedVar.name === '_';
}
function isMultipleMessageDescriptorDeclaration(id, importedVars) {
    const importedVar = findReferenceImport(id, importedVars);
    if (!importedVar) {
        return false;
    }
    return importedVar.name === 'defineMessages';
}
function extractMessageDescriptor(node) {
    if (!node || !node.properties) {
        return;
    }
    const result = {
        message: {},
        messageNode: undefined,
        descriptionNode: undefined,
    };
    result.message = node.properties.reduce((msg, prop) => {
        if (prop.key.type !== 'Identifier') {
            return msg;
        }
        const value = prop.value.type === 'Literal' && typeof prop.value.value === 'string'
            ? prop.value.value
            : undefined;
        switch (prop.key.name) {
            case 'defaultMessage':
                result.messageNode = prop.value;
                msg.defaultMessage = value;
                break;
            case 'description':
                result.descriptionNode = prop.value;
                msg.description = value;
                break;
            case 'id':
                msg.id = value;
        }
        return msg;
    }, {});
    return result;
}
function extractMessageDescriptorFromJSXElement(node) {
    if (!node || !node.attributes) {
        return;
    }
    let values = undefined;
    let messageNode;
    let descriptionNode;
    const message = node.attributes.reduce((msg, prop) => {
        if (prop.type !== 'JSXAttribute' || prop.name.type !== 'JSXIdentifier') {
            return msg;
        }
        const key = prop.name;
        switch (key.name) {
            case 'defaultMessage':
                messageNode = prop.value;
                msg.defaultMessage = prop.value.value;
                break;
            case 'description':
                descriptionNode = prop.value;
                msg.description = prop.value.value;
                break;
            case 'id':
                msg.id = prop.value.value;
                break;
            case 'values':
                values = prop.value
                    .expression;
                break;
        }
        return msg;
    }, {});
    if (!Object.keys(message).length) {
        return;
    }
    return [{ messageNode, descriptionNode, message }, values];
}
function extractMessageDescriptors(node) {
    if (!node || !node.properties) {
        return [];
    }
    return node.properties.reduce((msgs, prop) => {
        const msg = prop.value;
        const nodeInfo = extractMessageDescriptor(msg);
        if (nodeInfo) {
            return [...msgs, nodeInfo];
        }
        return msgs;
    }, []);
}
function extractMessages(node, importedMacroVars) {
    if (node.type === 'CallExpression') {
        const expr = node;
        const fnId = expr.callee;
        if (isSingleMessageDescriptorDeclaration(fnId, importedMacroVars) ||
            isIntlFormatMessageCall(node)) {
            const msgDescriptorNodeInfo = extractMessageDescriptor(expr.arguments[0]);
            if (msgDescriptorNodeInfo) {
                return [[msgDescriptorNodeInfo, expr.arguments[1]]];
            }
        }
        else if (isMultipleMessageDescriptorDeclaration(fnId, importedMacroVars)) {
            return extractMessageDescriptors(expr.arguments[0]).map(msg => [msg, undefined]);
        }
    }
    else if (node.type === 'JSXOpeningElement' &&
        node.name &&
        node.name.type === 'JSXIdentifier' &&
        node.name.name === 'FormattedMessage') {
        const msgDescriptorNodeInfo = extractMessageDescriptorFromJSXElement(node);
        if (msgDescriptorNodeInfo) {
            return [msgDescriptorNodeInfo];
        }
    }
    return [];
}
exports.extractMessages = extractMessages;
//# sourceMappingURL=util.js.map